### 2020-03-11(수)

-----

##### 1. 학습 날짜

- 2020-03-11(수)

-----

##### 2. 학습 시간

- 10:00 ~

-----

##### 3. 학습 범위 및 주제

- 네트워크 개념
- 소켓 프로그래밍
- printf 리팩토링
- printf 테스트
- gdb peda 사용법 익히기

-----

##### 4. 동료 학습 방법

- 온라인으로 진행

-----

##### 5. 학습 목표

- 모든 케이스에 작동하는 printf를 구현한다.
- printf함수를 norm에 맞춰 리팩토링 한다.
- 네트워크의 개념을 익힌다.
- 소켓 프로그래밍
- gdb에 익숙해진다.

-----

##### 6. 과제 제출 주소

- [Printf](http://git.innovationacademy.kr/sanam/Printf)

-----

##### 7. 상세 학습 내용

- printf 리팩토링
  - Norm 규정에 맞게 코드를 수정했다.  

<br>

- Makefile
  - libprintf.a의 경우 libft.a 라이브러리를 이용해서 만들어야 했다. 처음에는 libft의 모든 c 파일을 libftprintf.a의 makefile에 입력하려고 했는데 이렇게 만들면 makefile이 너무 보기 안좋아지므로 다른 방법을 찾아봤다. 결국에는 makefile을 이중으로 만들어서 make 명령어를 실행하면
    1. libft의 make 명령어를 실행시켜서 먼저 libft.a를 생성한다.
    2. 그리고 printf의 오브젝트 파일을 만든다.
    3. 마지막으로 libft.a와 printf의 오브젝트 파일을 이용해서 libftprintf.a을 만든다.
  - 위와 같은 방법으로 makefile을 만들었다.  

<br>

- 네트워크 개념 & 소켓 프로그래밍
  - TCP를 이해하기 위해서는 먼저 "TCP/IP 프로토콜 스택"을 알아야 한다. 이 스택은 인터넷을 통한 효율적인 데이터 전송을 위해서 만든 ***표준*** 이다. 이 네 개의 계층은
    1. LINK 계층 : 물리적인 영역의 표준
    2. IP 계층 : 데이터를 전송하는 경로를 선택해주는 프로토콜. 항상 일정치 않다. 신뢰성이 없다.
    3. TCP/UDP 계층 : 물리적인 영역이 준비되었고, 경로도 알았으니 이 계층에서는 실제로 송수신을 한다.
    4. APPLICATION계층 : 위 3가지 영역은 소켓을 생성하면 소켓이 알아서 해주는 과정이다. 하지만 APPLICATIOON 계층은 프로그래머가 직접 구현을 해야하는 부분.
  - TCP 서버에서의 기본적인 함수 호출 순서
    	1. 소켓 생성
     	2. 소켓 주소 할당
     	3. 연결 요청 대기 상태
     	4. 연결 허용
     	5. 데이터 송수신
     	6. 연결 종료
  - TCP 클라이언트의 기본적인 함수 호출 순서
    	1. 소켓 생성
     	2. 연결 요청
     	3. 데이터 송수신
     	4. 연결 종료  

<br>

- ft_server
  - docker
    - 도커를 사용하면 이미지와 컨테이너라는 개념을 이용해서 가상화를 보다 가볍고 쾌적하게 실행할 수 있다고 한다. 
    - 도커에서의 이미지와 컨테이너
      - 이미지는 소스코드 정보 등등이 담겨 있는 파일이다.
      - 컨테이너는 이미지를 실행 시킨 것이다. 따라서 이미지 하나만 있으면 여러 개의 컨테이너를 만들 수 있다.  

<br>

- 실제 코딩 시간
  - 약 6시간

-----

##### 8. 학습 내용에 대한 개인적인 총평

- Printf
  - 일주일 넘게 고생했던 printf를 오늘 마무리했다. Printf를 만들면서 가장 많이 생각한 건 이전에 했던 libft와 get next line이 좋은 밑거름이 되었다는 거다. 처음 get next line을 만들고 디버깅을 했을 때는 온통 memory leak 천지였는데, get next line보다 최소 5배는 긴 Printf를 디버깅 할 때는 memory leak 문제는 전혀 없었다. 이 점은 정말로 뿌듯하다. 다만 내가 만든 Printf는 코드가 길어도 너무 길다. 긴 이유는 간단하다. 하나의 함수를 다른 conversion에서도 사용 가능하게 만들어야 하는데 그렇게 하지 못하고 비슷한 내용의 코드를 conversion마다 반복하면서 만들었다. norm에 맞춰 수정하면서 이런 부분도 리팩토링 했어야 하는데 괜히 실행이 안될까 무서워서 손대지 못했다. 다음에 여유로울 때 꼭 수정해야겠다.  

<br>

- 소켓프로그래밍 chap4
  - 오늘은 chap1부터 chap3까지 복습을 하고 chap4 진도를 나갔다. chap4를 공부하고 나서야 비로소 chap1에서 했던 실습 코드가 이해가 되었다. 서버와 클라이언트는 다르다. 그리고 네트워크 바이트 순서와 호스트 바이트 순서는 꼭 같지는 않다.  

<br>

- docker
  - 솔직히 말해서 docker에 대해 많이 검색해보고 실행해 봤지만, 아직 왜 이토록 많은 사람들이 도커에 열광하는지는 모르겠다. 아직 내가 많이 부족한 것 같다. 오늘은 도커의 개념과 간단한 명령어 몇 개만 실행해 봤다. 첫 시작 치고는 괜찮은 편인 것 같다. 내일은 꼭 도커에 대해 더 자세히 알아봐야겠다.

-----

##### 9. 다음 학습 계획

- 네트워크 개념
- 네트워크 프로그래밍
- docker 개념
- docker 실습
- gdb peda 익숙해지기