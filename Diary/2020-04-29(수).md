



### 2020. 04. 29(수)

-----

##### 1. 학습 날짜

- 2020-04-29

-----

##### 2. 학습 시간

- 12:00 ~ 20:00

-----

##### 3. 학습 범위 및 주제

- minishell
- systemcall

-----

##### 4. 동료 학습 방법

- slack

-----

##### 5. 학습 목표

- pipe(), opendir(), execve() .. 시스템 콜 사용법 익히기
- 명령어 구현하기
- 프로세스 공부

-----

##### 6. 과제 제출 주소

- https://github.com/simian114/minishell

-----

##### 7. 상세 학습 내용

- 부모와 자식간의 데이터 공유
  - 현재 프로세스에 a = 1, b = 10 이라는 값이 저장되어 있다고 가정해보자. 만약 자식 프로세스를 생성해서 자식에서 이 값들을 변경하면 어떻게 될까?
  - 답은 부모에서는 변경되지 않는다 이다. 그렇다면 어떻게 하면 자식의 값을 부모에게로 전송할 수 있을까? 바로 파이프를 이용하는거다.
  - 이 파이프는 쉘에서 아주 중요한 역할을 한다. 왜냐하면 데이터의 전송이 불가능한 두 진영을 이어주는 역할을 하기 때문이다.
  - 간단히 요약하면 파이프는 한 쪽의 출력 부분에서 출력 값을 파이프의 입구로 연결시키고 데이터를 수신하는 쪽인 입력을 파이프의 출구에 연결시키는거다.
- 메모리
  - 위에서 말했다시피 자식과 부모는 데이터의 공유가 불가능하다. 따라서 동적 할당 된 데이터가 자식에게 도 전달되면 자식이 끝나기 전에 그 동적 할당된 녀석을 할당해제 해줘야 한다. 만약 해제하지 않고 exit 하게 된다면 큰 문제는 생기지 않지만 still reachable이라는 형태로 valgrind에 잡히기 때문에 꼭 free 해주자
- execve 시스템콜
  - 이 시스템콜은 주로 fork()와 같이 쓰인다. 이 시스템콜의 특징으로는 입력 받는 첫 번째 인자는 실행파일이라는 점이다. 즉 이 함수를 사용하기 전에 먼저 실행 파일로 만들어 두어야 하는 것이다. 두 번째 인자는 흔히 알고 있는 int main(int argc, char **argv) 에서의 argv이다. 주의 해야 할 것은 argv의 마지막을 널로 줘야한다는 것이다. 마지막 인자는 저기서 사용할 글로벌 변수다.
- clear 함수 구현
  - 아주 간단하게 구현했다.
- 실제 코딩 시간
  - 8시간

-----

##### 8. 오늘 학습 내용에 대한 개인적인 총평

- 오늘은 나름 알차게 보낸 것 같다. 항상 자기 전에 그 날 코딩한 것에 대한 생각을 한다. 특히 요즘은 minishell이 너무 재밌어서 잠도 안자고 이것만 생각하는 것 같다. 그리고 오늘은 어제 밤에 생각했었던 문제점들 위주로 코딩을 했다. 그리고 대부분 실행 가능하게 만든 점이 너무 신난다. 하지만 아직 진짜로 중요한 부분에 도달하지 않아서 즐거운거같다... 내일부터는 정말로 어려운 부분을 해야만 한다. 내일도 화이팅하자.

-----

##### 9. 다음 학습 계획

- input 값 조정하기.
- 리다이렉션.
- builtin 폴더도 컴파일 가능하게 makefile 수정하기. 안에 있는 c 파일들은 자신의 이름대로 컴파일 되도록 만들자.
- 전역변수 사용 가능하게 만들기
- strerror을 이용한 에러컨트롤