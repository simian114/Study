









### 2020. 04. 30(목)

-----

##### 1. 학습 날짜

- 2020-04-30

-----

##### 2. 학습 시간

- 12:00 ~ 16:00, 19:00 ~ 21:30

-----

##### 3. 학습 범위 및 주제

- waitpid
- minishell 의 여러 문제...

------

##### 4. 동료 학습 방법

- slack

-----

##### 5. 학습 목표

- Redirecton 해결
- Makefile 수정하기
- 자잘한 문제들 수정하기
- 전역변수

-----

##### 6. 과제 제출 주소

- https://github.com/simian114/minishell

-----

##### 7. 상세 학습 내용

- execve()

  - 이 시스템 콜을 사용하면서 계속 마음에 걸렸던게 있는데 아래의 예시 처럼 malloc된 인자를 넘겨주는 경우다.

    ```c
    int main()
    {
        char *temp[2] = {ft_strdup("MALLOC!"), NULL};
        execve("NAME", temp, NULL);
        // execve가 실행된 순간 이 프로세스는 저기로 아예 넘어가버린다.
    }
    ```

    위의 경우를 보면 temp[0]은 동적할당을 받은  상태이다. 따라서 함수가 종료 되기 전에 분명 동적 할당을 해제해 줘야하는데 인자가 넘어가는 순간 프로세스는 종료되고 NAME 에 인자로 전달되는 temp는 동적할당의 개념으로 가는게 아니기 때문에 너무 헷갈렸지만 알아본 결과 따로 해제를 해주지 않아도 되는 것 같다.

- command line에 여러개의 ; 가 있는 경우

  - 이 문제는 몇 일 전에 이미 해결했지만 문제가 아직 남아있었다. 생각을 해보니 인자로 들어온 명령을 ft_split을 통해서 나눠주면 아주 간단히 해결 할 수 있는 문제였다. 따라서 이전에 작성했던 함수를 모조리 없애고 ft_split를 통해 더욱 좋게 만들었다.

- 메모리 누수

  - 어제도 그렇고 오늘도 메모리 릭 문제를 잡으려고 애썼다. 오늘은 definitely 메모리 누수는 없었지만 어디에선가 계속 reachable 이 발생해서 이 문제를 잡으려고 애썼지만 결국 발견하지 못했다.... 앞으로도 함수를 구현 때 계속 주의해서 관찰해야겠다.

- wait && status

  - 자식 프로세스에서 execve를 이용하면 그 순간 자식 프로세스는 모조리 execve로 넘어간다. 따라서 execve의 exit 값을 알아야지 오류가 났는지 아닌지를 판별할 수 있는데, wstatus 변수를 확인하면 이상하게 256 값만이 출력이 되었다. 이 부분은 WIF... 뭐시기를 이용하면 execve에서 exit 한 값이 잘 나온다.

-----

##### 8. 오늘 학습 내용에 대한 개인적인 총평

- Minishell 구현은 이전의 cub3D나 다른 함수들과는 다르게 정말로 온 힘을 쏟고 최대한 잘해보기 위해서 노력하는 중이다. 그런데도 문제가 계속 발생한다. 이 부분을 고치면 저 부분에서 문제가 발생하고.. 다른 부분에서 메모리 문제가 발생하고... 메모리 문제는 메모리 누수만 있는게 아니라 이미 free 된 부분을 다시 free 하는 등의 문제가 있다. 오늘 하려고 했던 부분이 정말로 많은데 어제까지 만들었던 코드에서 잔 실수가 너무 많아서 이곳저곳 고치다 보니깐 오늘 하려고 했던 부분은 전혀하지 못했다. 함수를 빨리 구현하려는 것도 좋지만 일단은 정확하게 하도록 노력해야겠다.

-----

##### 9. 다음 학습 계획

- 리다이렉션
- 전역변수
- Makefile
- strerror && error