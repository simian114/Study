### 2020-05-10(일)

-----

##### 1. 학습 날짜

- 2020-05-10

-----

##### 2. 학습 시간

- 16:00 ~ 23:30

------

##### 3. 학습 범위 및 주제

- minishell

-----

##### 4. 동료 학습 방법

- slac

------

##### 5. 학습 목표

- 시그널

-----

##### 6. 과제 제출 주소

- https://github.com/simian114/minishell

-----

##### 7. 상세 학습 내용

- 시그널 구현

  - 지금까지 코딩을 해오면서 날 수 없이 괴롭히던 녀석이 있는데 그놈의 이름은 SIG ABORT다.
    오늘까지 시그널에 대해서 조금씩 공부하다가 수 많은 시그널의 종류에 저 녀석이 있는 것을 발견했다. 그렇다. 나는 몰랐지만 지금까지 SHELL은 나에게 무수히 많이 시그널을 주고 있던 거였다.. 난 혼자가 아니었다.. 본론으로 들어와서 내가 구현해야 하는 시그널은 SIGINT와 SIGQUIT다.
  - SIGINT
    - 이 녀석은 이름만 보면 잘 모르겠지만 이름을 늘려보면 interrupted 다. 즉 방해(?)를 받을 때 나오는 시그널이다. ctrl + c 를 쉘 에서 입력을 하면 이 signal이 나오는데 사용자가 이에 대한 handler를 설정하지 않으면 기본값으로 현재 실행되고 있는 프로세스를 죽인다. 이제 쉘에서의 이 녀석을 살펴보면 쉘 상에서 SIGINT가 입력되면 그냥 줄 바꿈이 되면서 새로운 prompt_msg가 뜬다. 따라서 나도 그렇게 핸들러 함수를 구현했다.
  - SIGQUIT
    - 이 녀석은 이름만 봐도 한 번에 알 수 있겠지만, 프로세스를 죽이는 시그널이다. 쉘에서의 활용을 보면 아무런 변화가 없다..;; 따라서 나도 이 시그널이 들어오면 아무런 영향이 없게 만들었다.

- EOF

  - 사실 시그널은 개념이 어렵지 쉘 상에서의 작동 방식은 너무나 단순해서 구현하는게 간단했지만, EOF의 구현은 조금 까다로웠다. 왜냐하면 이 EOF를 구현하기 위해서는 read 를 수정해야만 했기 때문이다. 일단 내 코드에서 이 EOF에 대해 말해보자면

    - ``` c
      while (read(STDIN_FILENO, buf, 1, *buf != '\n')
             ...
      ```

      와 같은 코드가 있을 때 EOF를 고려하지 않았을 때 에는 ENTER를 입력하기 전까지 계속 키보드로의 입력을 받는다. 하지만 EOF가 나온다면? EOF로 인해 키보드로의 입력이 끊기게 된다. 즉 ENTER과는 상관없이 입력이 종료되는 거다. 이 부분 때문에 내 코드에서 수정 할 부분이 조금 많았다. 

  - 작동 방식을 살펴보면 STDIN_FILENO 를 통해 무언가 입력이 된 상황에서 EOF 를 입력하면 아무런 동작도 하지 않는다.
    하지만! 비어있는 경우에 EOF를 주면 쉘이 종료된다. 따라서 이 부분도 고려해서 함수를 구현했다.

- 코딩 시간

  - 7시간

-----

##### 8. 오늘 학습 내용에 대한 개인적인 총평

- 어제와 오늘은 많은 부분을 하지 않았다. 그렇다고 꼼꼼하게 하지도 않았다.. 게을러 빠진 모습으로 게을러 빠지게 코딩을 했다. 그래도 minishell 완성의 고지가 얼마 남지 않았다. 이제 함수의 norm 체크를 하고 함수를 작게 작게 쪼개는 작업을 조금 하면 될 것 같다.

-----

##### 9. 다음 학습 계획

- 컴퓨터 공학 이론 공부
- minishell 마무리