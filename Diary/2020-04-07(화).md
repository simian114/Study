### 2020-04-07(화)

-----

##### 1. 학습 날짜

- 2020-04-07

-----

##### 2. 학습 시간

- 10:00 ~ 22:00

-----

##### 3. 학습 범위 및 주제

- liibft
- get next line

-----

##### 4. 동료 학습 방법

- slack(iwoo, hna, gmoon)
- team viewer

-----

##### 5. 학습 목표

- eval 포인트  쌓기...
- libft 통과하기
- get next line bonus 구현하기

-----

##### 6. 과제 제출 주소

- https://github.com/simian114

-----

##### 7. 상세 학습 내용

- libft 수정
  - ft_calloc
    - 어제 틀렸던 이유가 size == 0 또는 nmemb == 0 일 때 malloc(0)을 안해줘서였던걸로 파악하고 수정을 해줬는데 오늘 채점 결과 또 틀렸다. 다른 분들에게 피드백을 받은 결과 calloc 는 0으로 초기화 해주는 과정에서 ft_bzero 함수를 썼었는데 이번에는 그 함수를 사용하지 않고 직접 모든 주소마다 아스키 0 값을 넣었다.
  - ft_strdup
    - 이 함수는 만약 src의 길이가 0 인 경우 malloc 을 아예 하지 않고 바로 return(0)을 했다. 이렇게 하면 안되고 len == 0 인 경우에도 malloc(1)을 한 다음에 return 하게 바꾸고 맞았다.
  - ft_memchr
    - 이 문제는 숫자 카운팅이 문제였던걸로 판단되서 그 부분을 수정해서 제출했다. 결국 맞았다.
  - ft_split
    - 이 함수는 문제점을 알아내지 못했다. 따라서 다시 함수를 구현했다. 지난 날이 도움이 됐는지 함수를 더 깔끔하고 멋있게 구현할 수 있었다.
- get next line
  - 이전에 함수를 구현할 때 모든 부분에 대해서 이차원 포인터를 사용했었는데 bonus를 구현하는 경우에는 그냥 포인터에 [fd] 만 붙여주면 됐다. 따라서 쉽게 구현할 수 있었다.

-----

##### 8. 학습 내용에 대한 개인적인 총평

- 오늘은 일단 어제 틀린 libft를 다시 채점받았다. 하지만 채점을 받기 위해서는 포인트가 필요했는데 이 포인트를 버는게 너무 힘들었다. 아침 일찍부터 계속 했는데 몇 번 채점하지도 못했다. 결국 3점을 모아서 채점을 받긴 했는데 이번에도 또 틀려 버렸다. 이 틀린 문제들을 자세히 살펴보고 연구해 봤는데 아마 ft_calloc 같은 경우에는 포인터 자체의 크기에서 문제가 생긴거 같다. 따라서 값을  초기화 해 줄 때 원소 하나하나를 char *로 형 변환해서 아스키 0 값을 넣었다. 그리고 ft_split도 또 틀려서 이 문제는 처음부터 다시 구현을 했다. 다음부터는 확실하지 않으면 아예 채점을 받으면 안될거 같다. 너무 힘들다...

-----

##### 9. 다음 학습 계획

- eval 포인트 얻기
- libft 재채점
- libft 수정
- get next line 수정
- get next line 제출

