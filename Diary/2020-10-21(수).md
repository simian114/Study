### 2020-10-21

-----
##### 1. 학습 날짜
- 2020-10-21

-----
##### 2. 학습 시간
- 08:00 ~ 19:30

-----
###### 3. 학습 범위 및 주제
- 문제풀이

-----
##### 4. 동료 학습 방법
- slack

-----
##### 5. 학습 목표
- 서버를 동작시키고 Request 를 받도록 테스트 한다.

-----
##### 6. 과제 제출
- https://github.com/get-Pork-Belly/Webserv
- https://github.com/leecoleecolee/ProblemSolving/tree/sanam

-----
##### 7. 상세 학습 내용

- 문제풀이
    - 오늘의 문제풀이는 투라이 자료구조를 이용한 유효한 팰린드롬을 찾는 문제.
    - 어제 학습한 트라이 자료구조였기 떄문에 트라이 트리까지는 구현했지만 도저히 풀 방법을 찾을수가 없었다. 정답을 봐도 이해할 수가 전혀 없었다... 역시 내 머리는 조금.. 나쁜가보다.

- 웹서버
    - 오늘은 Chunked에 대한 이슈, 클라이언트의 소켓을 어떻게 닫을지에 대한 이슈 때문에 하루종일 거의 아무것도 하지 못했다.
    - 그래도 어느 정도 해결은 했기에 정리를 해보겠다.
    - 소켓 close에 대한 이슈
        - 클라이언트가 처음 요청을 하면 서버소켓은 클라이언트를 `accept`한다. 그렇게 되면 클라이언트 소켓fd가 생긴다.
        - 수정하기 전에는 요청을 읽고, 이에대한 응답을 만든다음 클라이언트에게 전송하면 클라이언트 소켓fd를 바로 close했다.(물론 read-fd-set도 초기화한다.)
        - 하지만 이렇게 되면 `persistent-connection`이 전혀 없게 된다. `http1.1` 버전 이전에는 전송과 동시에 연결을 끊어 버렸지만 그렇게 된다면 지속적인 요청에 대해 계속 클라이언트를 생성하고 삭제하는 과정에서의 오버헤드가 생기기 때문에 1.1부터는 지속가능한 연결을 하게 된 것인데, 우리가 만든 코드는 이런 지속 가능한 연결을 아예 무시하는 것.
        - 이 문제를 어떻게 할 것인가에 대해 고민했는데, 답은 생각보다 간단했던거 같다. 데이터를 보낼 때 소켓을 삭제하는게 아니라 데이터를 보내고 나서도 서버는 소켓을 계속 살려두게 한다. 살려 둠고 동시에 read_fd_set의 플래그를 내리지 않음으로써 서버가 클라이언트를 계속 감시하게 만들었다. 만약 MSG_PEEK으로 내다 본 값이 0 또는 1 이라면 클라이언트가 직접 연결을 끊은것이기에 이 떄 서버는 클라이언트를 close 하면 된다.

    - 위와 같은 방법 덕분에 지속 가능한 연결이 가능해졌고, 그리고 이 덕분에 `chunked` 연결을 해결할 실마리를 얻었다. 물론 아직 해결한 건 아니지만...
     
-----
##### 8. 오늘 학습 내용에 대한 개인적인 총평
- 오늘 구조를 바꾼 것은 정말 훌륭하다고 생각한다. ㅎㅎㅎㅎ 하지만 그뿐이다.. 너무 진도가 느리다..

-----

##### 9. 다음 학습 계획

- 웹서버 설계 및 구현
- 문제풀이
