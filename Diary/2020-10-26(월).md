### 2020-10-26

-----
##### 1. 학습 날짜
- 2020-10-26

-----
##### 2. 학습 시간
- 08:00 ~ 20:30

-----
###### 3. 학습 범위 및 주제
- 문제풀이
- 웹서버 설계 및 구현

-----
##### 4. 동료 학습 방법
- slack

-----
##### 5. 학습 목표
- 서버의 동작 방식을 익히고 그에 맞게 설계 및 구현을 한다.
- 문제풀기

-----
##### 6. 과제 제출
- https://github.com/get-Pork-Belly/Webserv
- https://github.com/leecoleecolee/ProblemSolving/tree/sanam

-----
##### 7. 상세 학습 내용
- 웹서버
    - 오늘은 웹서버의 전체적인 구조에 대한 설계를 다시했다. 기존의 방식으로 구조를 짜면 서브젝트에 위배되는 사항이 있었다. 이야기 해보자면, 서브젝트에는 select 함수 한번 당 오직 단 한번의 read, wrtie 만을 허용한다는 말이 있다. 이 말인 즉슨, 통신을 제외한 파일을 read하는 부분, cgi에서 read 해오는 경우 모두 select에 걸려야 한다는 것. 기존에 우리는 select 당 통신에 사용되는 read 또는 write 만을 단 한번만 사용하고 나머지의 경우에 대해서는 고려하지 않았었다.
    - 그렇다면 그 부분을 어떻게 해결했냐... 아주 멋드러진 방법을 구조를 변경했다.
    - 먼저 가장 중요한 부분은 `Servermanager`에서 모든 fd를 관리하는 변수를 하나 만드는 것이다. 이 변수의 타입과 이름은 다음과 같다. `std::vector<std::pair<Fd_Type, int> > _fd_table`. 이 변수는 프로그램이 돌아가는 동안 Closed 되지 않은 모든 fd를 관리한다. 최고의 성능을 갖기 위해서 이 벡터의 크기는 init 할 떄 1024로 생성한다.(select에서 관리할 수 있는 최대 fd가 1024이므로). 그리고 FD가 생성되는 경우에 FD값을 인덱스로 `_fd_table`로 접근한다. 이후에 현재 생성된 fd의 타입을 first에 넣는다. 그리고 second에는 이 타입과 관련된 fd를 넣는다. 가령 예를 들면 Server 소켓이 생성될 땐 second를 -1로 초기화한다. client 소켓이 생성될 때는 해당 client 소켓을 accept한 서버의 fd를 넣는다. Resource 또는 PIPE 타입일 경우에는 client의 fd를 넣는다. 이런 방식으로 초기화를 하면 효과적으로 코드를 만들 수 있게 된다.  

-----
##### 8. 오늘 학습 내용에 대한 개인적인 총평
- 흠... 뭔가 굉장히 힘든 하루였지만, 앞으로 웹서버를 어떻게 만들지에 대한 확신?이 생긴 날이다. 

-----

##### 9. 다음 학습 계획

- 웹서버 설계 및 구현
- 문제풀이2020
