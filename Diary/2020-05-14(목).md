### 2020-05-14(목)

-----

##### 1. 학습 날짜

- 2020-05-14

-----

##### 2. 학습 시간

- 09:00 ~ 11:00

-----

##### 3. 학습 범위 및 주제

- 네트워크 공부
- 리눅스 공부
- ansi 코드

-----

##### 4. 동료 학습 방법

- slack

-----

##### 5. 학습 목표

- 네트워크 데이터 링크 계층에서 동작하는 에러체킹
- 리눅스의 이해
- ANSI 코드

-----

##### 6. 과제 제출 주소

- X

-----

##### 7. 상세 학습 내용

- 데이터링크 계층에서 에러 제어에는 크게 두 가지 관점이 있는거 같다.

  1. 에러 정정
  2. 에러 감지

  첫 번째로 적은 에러 정정은 만약 에러가 검출 되면, 검출 된 에러 부분을 수정하는 것이고

  두 번째인 에러 감지는 에러가 발견되면 송신자한테 재전송을 요구 하는 것이다.

  에러 정정의 대표적인 기술로는 해밍 코드가 있다.

  해밍코드는 보내고자 하는 정보에 여분의 데이터를 덧붙여서 보내는 것이다.

  송신자는 여분의 데이터가 덧 붙여진 코드를 받게 되고 체크비트의 계산을 통해 만약 오류가 검출되면 수정할 수 있게 되는 거다.

  만약 A 를 전송한다고 하자 A는 2비트로 1000001 이다. 7자라이므로 m = 7이다. (8 + p) < = 2^p 계산을 하면 p의 최소값은 4이다. p를 4로 설장하자. 그렇게 하면 기존 길이 7에 4 를 더해서 11개 비트의 정보를 송신한다. 수신자는 이제 11개의 비트를 받게되는데, 00100001001 이라는 데이터를 수신받았다고 해보자. 체크 비트는 1, 2, 4, 8, .. 로 2의 제곱수다.

  위에 $라고 표시된 비트들이 체크 비트다.

  $-$-0-$-0-0-0-$-0-0-0

  0-0-1-0-0-0-0-1-0-0-1

  체크 비트만 따로 빼면은, 0001 의 값을 갖게 된다. 이제 체크비트가 아닌 비트에서 1이 자리수를 따져보면,

  3과 11이다. 3과 11를 이제 XOR 시키자.

  0011

  1011 ⇒ 1000 이다. 이제 1000을 뒤집으면 0001로 앞에서 체크비트로 구한 0001이 되므로 보내진 값을 옳은 값이다.

  만약 보내진 데이터가

  $$0$000$000

  00101001001 이라면 어떻게 될까?

  체크비트 = 0001

  3, 5, 11 이므로 0011 0101 1011 이 셋을 XOR 하면 0101이 된다.

  1101을 뒤집으면 1011 체크비트인 0001과 다르다. 따라서 보내진 값은 옳은 값이 아니다.

  이전에 해밍 방법은 정정할 수 있다고 했는데 어떻게 정정할까? 아까 세 값을 XOR 해서 구해진 0101의 십진수 값은 5다. 즉 보내진 데이터에서 5번 째 비트가 잘 못 되었다는 것이다. 이제 이 값을 flip 해주면

  00100001001이 되므로 옳은 값으로 변환이 된다.

  1. 에러 감지의 방법

  CRC (다항식 방법)

  이 방법은 비트 스트링을 0과 1의 계수를 가진 다항식으로 간주하는 방법이다. 예를 들어서 설명하면

  1101011011 이라는 프레임과 Gx = x^4 + x + 1 이라는 제너레이터가 있다. 제너레이터의 차수가 4이므로 프레임의 뒤에 네 개의 0 비트를 더한다. 그러면

  11010110110000 이라는 값이 생기고, 이 값을 이제 Gx로 XOR 연산으로 나눠주면 생기는 나머지를

  11010110111 뒤에 붙여서 보내는거다.

  11010110110000을 Gx(10011)로 나눠주면 1110이 남으므로 이 값을 기존의 프레임에 더하면

  11010110111110 이 된다. 이제 송신자는 이 값을 정해진 Gx로 나눠주면 되는거다. 만약 나머지가 0이 아니라면 오류가 생긴거고 송신자는 수신자한테 재전송을 요구하면 된다.

  슬라이딩 윈도우 프로토콜

  - 송신자와 수신자는 데이터를 주고 받을 때 양방향이 될 수도 있고 단방향이 될 수도 있는데, 수신자가 전송을 잘 받았다는 메시지를 보내기 위해서는 당연히 양 방향이 되어야만 한다.
  - 이제 A와 B를 가정하자
  - A와 B는 서로가 데이터를 주고 받는데, A가 B한테 제이터를 전송하면 B는 A한테 ack 메시지를 보내고 또 다른 데이터를 A한테 전송한다....
  - 위에서의 문제는 ack라는 메시지만들 보내기 위해서 애써야 한다는 점이다. 즉 자원의 낭비가 발생한다는 점이다. 그러면 어떻게 해결할까?
  - 그냥 B가 A한테 데이터를 전송할 때 그 때 이전에 보내야했던 ack 메시지를 헤더에 추가해서 보내는 걸로 하면 된다.
  - 위와 같은 기법을 피기백 방식이라한다.
  - 이런 양방향 프로토콜로 슬라이딩 윈도우 프로토콜이 존재하는데 3가지 방법이 존재한다.
    1. 1 bit 슬라이딩
       - 송수신 측은 1비트 사이즈 만큼만 전송한다. 하나의 패킷을 전송하고 응답이 오기 전까지는 다음 파켓을 전송하지 않는다
    2. Go Back N 방식
       - 에러가 난 부분이 있으면 그 이후에 받은 부분을 없는셈치고 에러가 난 부분에서 부터 다시 데이터를 전송받는다.
    3. 선택적 재전송
       - 잘 못 보낸게 있으면 그 부분에 대해서만 다시 보내는 걸 요청한다. 따라서 송신자가 그 잘 못 보낸 부분을 전송하면 다시 원래의 순서로 돌아와서 데이터를 수신받는다.

- 리눅스
  - 디바이스 드라이버란 프로세스가 디바이스를 조작할 수 있게 해주는 프로그램.
  - 시스템 콜이란 프로세스가 디바이스 드라이버를 포함한 커널이 제공하는 기능을 사용할 때 이용하는 특수한 처리.
  - CPU는 동시에 여러개의 프로세스를 실행시킬 수 는 없다. 따라서 스케줄러를 통해 알맞게 실행시켜야한다.
- ANSI코드
  - 이전에 minishell을 할 때 조금 마음에 걸렸던 부분이 시그널을 주면 그 입력이 그대로 남아 있었다는 점이다. ANSI 코드를 이용하면 터미널 상에서 커서의 위치를 조작할 수 있고 그것 뿐만이 아니라 지우는 기능까지도 제공한다. 이걸 이용해서 시그널을 처리하고 남는 ^\ ^C 등의 문자를 지울 수 있게 됐다.

- 실제 코딩 시간 2시간

-----

##### 8. 오늘 학습 내용에 대한 개인적인 총평

- 많은 양을 공부했다... 머리가 너무 아프다. 그래도 컴퓨터 공부는 너무 재밌다. 이론도 뭔가 재밌게 느껴지기 시작해버렸다. 열심히 해서 성공할거다.

-----

##### 9. 다음 학습 계획

- 리눅스

-----

