-----
#### vim tips
-----
##### 1. 매크로 사용법

- 어떤 명령어들을 반복적으로 여러번 사용해야 하는 상황을 가정해보자. 만약 그 명령어들을 어느 변수에다가 저장을 해두고 필요할 때 마다 꺼내 쓸 수 있다면 얼마나 좋을까? ***VIM***은 이를 가능하게 한다.

	1. 이런 매크로를 저장할 수 있는 변수. 즉 ***레제스터*** 는 a 부터 z 까지 총 ***26*** 개다.
	2. 먼저 ***q*** 를 누르고 저장하고 싶은 ***알파벳*** 을 누른다.
	3. 그러면 아래의 명령창에 ***recoding*** 이 뜨는데, 이 때 저장하고 싶은 명령어를 순서대로 입력한다.
	4. 입력이 끝나면 ***q*** 버튼으로 나가자. 그리고 저장한 매크로를 마음 껏 사용하자.

- examples 현재 커서가 위치한 행을 주석 처리 하는 매크로

  ``` c
  1. qa  
  2. ^i // <space><esc><enter>
  3. q
  ```

- 반대로 주석을 없애는 매크로

  ``` c
  1. qb
  2. ^3x<enter>
  3. q
  ```

  

-----

##### 2. 반복적인 문자열을 레지스터에 저장해서 사용하기

- 매크로와 마찬가지로 ***레지스터*** 에 반복되는 문자열을 저장해서 쉽게 사용할 수 있다.

- ***현재 커서를 기준으로 3줄이 반복되는 문자열일 때, 레지스터 a에 저장하고 사용하는 방법***

  ``` c
  1. 레지스터 a 에 저장 "a3yy
  2. 붙여넣기			 "ap   
  ```

-----

##### 4. 여러 파일을 편집하는 방법

1. ***vim 1.c 2.c 3.c*** 처럼 파일을 연다.

2. 명령창에  아래 명령어를 입력한다.

   ``` c
   :ls
   ```

   그러면 열려있는 모든 ***파일 버퍼***  목록이 뜬다.

3.  만약 ***2번 파일 버퍼*** 로 이동하고 싶다면 아래와 같은 명령어를 입력한다.

   ``` c
   :b2 // 편집하고싶은 파일의 숫자
   ```

-----

##### 5. 명령어를 간단한 단축키로 mapping 하는 방법

1. 위의 ***:b2*** 를 ***,2*** 로 매핑 시키는 예시

   ``` c
   :map ,2 :b!2<CR>	// :b2를 ,2로 매핑
       				// ,2를 입력하는 타이밍이 중요하다ㅋㅋㅋㅋ
       				// 너무 빠르거나 너무 느리게 ,2를 입력하면 말짱 도루묵!
   ```

2.  mapping을 영구적으로 싶을 땐 ***vimrc*** 파일을 수정해주자!

   ``` c
   1. vim ~/.vimrc
   2. :map ,b :b!2<CR> //
   ```

-----

##### 6. 현재의 작업 위치를 기억하기

1. 매우 긴 파일을 편집하는 상황을 가정하자.

2. 현재 작업하고 있는 위치에서 아주 멀리 떨어진 곳에 존재하는 줄을 참고할 때 멀리 떨어진 곳으로 이동할 때는 간단하게 ***&#47;string*** 으로 이동하면 쉽다. 하지만 돌아올 때는? 작업하고 있는 위치의 라인을 종이에 적어 놓을까?

3. 아니다. ***Marking*** 해 놓으면 된다. 아래는 사용법이다.

   ``` c
   ma		// m은 마킹 명령어고, a는 문자 a에다 그 위치를 넣는다는거디.
   'a		// 이렇게하면 a에 마킹되어 있는 위치로 순간이동!
   ```

-----

##### 7.  VIM에서 편집 중에 셀 명령어를 참고해야 하는 경우

##### 7. 파일을 편집하면서 셀 명령어를 사용해야 하는 경우

1. ***!ls*** 와 같이 ***! + [명령어]***  로 하면 현재 편집기를 잠깐 빠져나가고 ***ls*** 명령어의 실행 결과를 알 수 있다.

2. 그렇다면, 만약에 ***셸 명령어의 결과를 현재 편집하고 있는 곳에 붙여 넣고 싶다면?*** 

   ``` c
   :r !ls			// ls의 결과를 현재 편집하고 있는 커서의 위치에 붙여 넣는다.
   
   // 만약 현재 파일을 컴파일하고 그 결과를 바로 현재 커서에 붙여 넣고 싶을 땐
   :r !gcc -o test test.c && ./test 
   ```

-----

##### 8. 함수를 폴딩하는 방법

- 어떤 함수가 있다. 그 함수는 너무 길어서 다른 함수를 분석하는데 지장이 생긴다. 이런 경우에 그 함수를

- ***접을 수 있다***

  ``` c#
  int		func(int a, int b)
  {
      printf("시작 중괄호에 커서를 위치 시키고\n");
      printf("아래의 명령을 : 와 같은 명령행이 아닌 그냥 입력하자");
      printf("v}]zf");
      printf("폴딩한 함수를 다시 펴고 싶을 땐");
      printf("?? 또는 zo");
  }
  ```

- 다소 어렵다. 그러면 아까 위에 적어놓은 ***mapping*** 을 이용하자!

  - ***map <F11> v}]zf***
  - ***map <F12> zo***

-----

##### 9. 현재 커서에 위치한 함수의 원형이 궁금하다.

- 현재 커서에 위치한 함수의 원형을 알고 싶다.

- 그런데 다른 파일에 선언되어 있다. 그러면 헤더파일에서 찾아야겠지?

- ***아니다!!*** 그냥 ***[i*** 를 입력하자.

  ``` c
  // 함수가 사용된 곳에 커서를 두고
  [i	// 입력
  ```

-----

##### 10. 인터넷에서 소스코드를 복사해서 현재 파일에 붙여 넣었을 때 소스코드가 흐트러지는 현상.

- block 지정 후 ***=*** 입력.

- 만약 파일 전체에 대해서 적용하고 싶을 때는

  ``` c
  gg=G
  ```

-----

##### 11. vim 에서 파일을 편집하면서 바로 man page를 보고 싶을 땐, 커서를 위치시키고 ***shift + k***

- 그런데 man page는 셸 부터 c언어 까지 하나의 함수에 몇가지의 man이 동시에 존재할 수 있다.

- 이런 경우에 셸의 man page를 가장 먼저 보여준다.

- .vimrc를 수정해서 원하는 함수 위에

  ``` c
  ,ma
  ```

  를 입력하면 바로 c언어의 man page로 넘어가도록 지정했다.

-----

##### 12. indent line을 보고싶다!!

	```
		vim ~/.vimrc
		set listchars=tab:\|\  ====> 마지막 \ 뒤에 꼭 공백을 붙여주자!
		set list
	```

- 위의 방법은 tab으로 indention할 때의 방법이다. 만약 space로 indent를 하는 경우에는 플러그인을 사용하자
